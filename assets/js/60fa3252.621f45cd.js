"use strict";(self.webpackChunkapollo_docs=self.webpackChunkapollo_docs||[]).push([[881],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,h=d["".concat(l,".").concat(m)]||d[m]||p[m]||o;return n?a.createElement(h,i(i({ref:t},u),{},{components:n})):a.createElement(h,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4392:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return p}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],s={sidebar_position:1},l="Introduction",c={unversionedId:"schema/intro",id:"schema/intro",title:"Introduction",description:"The schema is in the form of a DSL implemented with HCL to define the data",source:"@site/docs/schema/intro.md",sourceDirName:"schema",slug:"/schema/intro",permalink:"/schema/intro",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Schema",permalink:"/category/schema"},next:{title:"Context variables and functions",permalink:"/schema/context-variables-functions"}},u={},p=[{value:"Variables",id:"variables",level:2},{value:"Query",id:"query",level:2},{value:"Global Events",id:"global-events",level:3},{value:"Contracts",id:"contracts",level:3},{value:"Contract Methods",id:"contract-methods",level:3},{value:"Contract Events",id:"contract-events",level:3},{value:"Processing Data",id:"processing-data",level:2},{value:"Transform",id:"transform",level:3},{value:"Filter",id:"filter",level:3},{value:"Save",id:"save",level:3}],d={toc:p};function m(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"The schema is in the form of a DSL implemented with ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/hashicorp/hcl"},"HCL")," to define the data\nwe're interested in. This means that basic arithmetic operations and ternary operators\nfor control flow are supported by default. "),(0,o.kt)("h2",{id:"variables"},"Variables"),(0,o.kt)("p",null,"We can start by defining variables in a ",(0,o.kt)("inlineCode",{parentName:"p"},"variables")," map. For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-hcl"},'variables = {\n  weth_address = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2"\n}\n')),(0,o.kt)("p",null,"These variables will be available for use across the rest of our schema."),(0,o.kt)("h2",{id:"query"},"Query"),(0,o.kt)("p",null,"The next top-level element is always a ",(0,o.kt)("inlineCode",{parentName:"p"},"query")," block, along with the name of the query.\nThis name will be used to determine the name of the output file or the name of the table in a database.\nFor example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-hcl"},'query usdc_eth_swaps {\n  chain = "ethereum"\n\n  ...\n}\n')),(0,o.kt)("p",null,"This ",(0,o.kt)("inlineCode",{parentName:"p"},"query")," with CSV output enabled would create ",(0,o.kt)("inlineCode",{parentName:"p"},"usdc_eth_swaps.csv"),", and with database output we would get the\n",(0,o.kt)("inlineCode",{parentName:"p"},"usdc_eth_swaps")," table."),(0,o.kt)("p",null,"In the ",(0,o.kt)("inlineCode",{parentName:"p"},"query")," block, we must define the ",(0,o.kt)("inlineCode",{parentName:"p"},"chain"),". This will determine the RPC for the query, and your chain name\nmust correspond to a chain in the configuration file (",(0,o.kt)("inlineCode",{parentName:"p"},"config.yml"),"). ",(0,o.kt)("strong",{parentName:"p"},"For now, only one query at a time is supported"),".\nLater, you will be able to execute multiple queries over multiple chains at the same time, for data that has\ncross-chain relevance."),(0,o.kt)("p",null,"Everything in a ",(0,o.kt)("inlineCode",{parentName:"p"},"query")," block needs to happen at the same time. This means that you can't call a method ",(0,o.kt)("strong",{parentName:"p"},"and"),"\nfilter for events in one query (unless you're calling a method when a certain event occurs)."),(0,o.kt)("p",null,"This is where things become interesting. Inside of the ",(0,o.kt)("inlineCode",{parentName:"p"},"query")," block we can choose between a couple of options: ",(0,o.kt)("strong",{parentName:"p"},"global events"),"\nand ",(0,o.kt)("strong",{parentName:"p"},"contracts"),". Let's start with the first."),(0,o.kt)("h3",{id:"global-events"},"Global Events"),(0,o.kt)("p",null,"If we want to query certain events that are not tied to a specific address, we create an ",(0,o.kt)("inlineCode",{parentName:"p"},"event")," block inside of the ",(0,o.kt)("inlineCode",{parentName:"p"},"query")," block.\nFor example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-hcl"},'query all_arbitrum_transfers {\n  chain = "arbitrum"\n\n  event Transfer {\n    abi = "erc20.abi.json"\n\n    ...\n  }\n}\n')),(0,o.kt)("p",null,"This query would look for all of the ERC20 ",(0,o.kt)("inlineCode",{parentName:"p"},"Transfer")," events that happen on the ",(0,o.kt)("strong",{parentName:"p"},"Arbitrum")," rollup. Since ",(0,o.kt)("inlineCode",{parentName:"p"},"Transfer")," is\ndefined in the ERC20 ABI, we need a property inside ",(0,o.kt)("inlineCode",{parentName:"p"},"event")," to specify the ABI."),(0,o.kt)("h3",{id:"contracts"},"Contracts"),(0,o.kt)("p",null,"The other option is a ",(0,o.kt)("inlineCode",{parentName:"p"},"contract")," block. This allows you to ",(0,o.kt)("strong",{parentName:"p"},"call methods")," or ",(0,o.kt)("strong",{parentName:"p"},"filter events")," that are tied to a specific\ncontract. For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-hcl"},'query usdc_eth_reserves {\n  chain = "arbitrum"\n\n  contract {\n    address = "0x905dfCD5649217c42684f23958568e533C711Aa3"\n    abi = "unipair.abi.json"\n\n    ...\n  }\n}\n')),(0,o.kt)("p",null,"This in itself is not a very useful example, let's continue with ",(0,o.kt)("strong",{parentName:"p"},"calling methods"),"."),(0,o.kt)("h3",{id:"contract-methods"},"Contract Methods"),(0,o.kt)("p",null,"Building on the last example, let's see how we can call ",(0,o.kt)("inlineCode",{parentName:"p"},"getReserves")," and define which outputs we want for further processing:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-hcl"},'query usdc_eth_reserves {\n  chain = "arbitrum"\n\n  contract {\n    address = "0x905dfCD5649217c42684f23958568e533C711Aa3"\n    abi = "unipair.abi.json"\n\n    method getReserves {\n      outputs = ["_reserve0", "_reserve1"]\n    }\n\n    ...\n  }\n}\n')),(0,o.kt)("p",null,"The method name ",(0,o.kt)("inlineCode",{parentName:"p"},"getReserves")," and the output names ",(0,o.kt)("inlineCode",{parentName:"p"},"_reserve0")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"_reserve1")," are exactly how they are defined in the ABI,\nso be careful with typos. This method has one more output (",(0,o.kt)("inlineCode",{parentName:"p"},"_blockTimestampLast"),"), but since we're not interested in that,\nwe can just omit it."),(0,o.kt)("h3",{id:"contract-events"},"Contract Events"),(0,o.kt)("p",null,"Contract level events are almost the same as global events, but there's no need for an ",(0,o.kt)("inlineCode",{parentName:"p"},"abi")," property. For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-hcl"},'query usdc_eth_swaps {\n  chain = "arbitrum"\n\n  contract {\n    address = "0x905dfCD5649217c42684f23958568e533C711Aa3"\n    abi = "unipair.abi.json"\n\n    event Swap {\n      outputs = ["amount1In", "amount0Out", "amount0In", "amount1Out"]\n    }\n\n    ...\n  }\n}\n')),(0,o.kt)("p",null,"Would allow you to look at all the swaps on the USDC-ETH SushiSwap pool on Arbitrum, and save the outputs for\nfurther processing."),(0,o.kt)("h2",{id:"processing-data"},"Processing Data"),(0,o.kt)("p",null,"We've talked a lot about ",(0,o.kt)("strong",{parentName:"p"},"how")," we're supposed to get our data, now let's see ",(0,o.kt)("strong",{parentName:"p"},"what")," we can do with it."),(0,o.kt)("h3",{id:"transform"},"Transform"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"contract")," and global ",(0,o.kt)("inlineCode",{parentName:"p"},"event")," blocks can have additional ",(0,o.kt)("inlineCode",{parentName:"p"},"transform")," blocks. These blocks can work with previously fetched\ndata to do some transformations, before proceeding to the final output. Any ",(0,o.kt)("inlineCode",{parentName:"p"},"input")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"output")," is automatically provided\nas a variable to work with, along with some helper functions like ",(0,o.kt)("inlineCode",{parentName:"p"},"parse_decimals()"),". More on this\n",(0,o.kt)("a",{parentName:"p",href:"/schema/context-variables-functions"},"here"),". Let's look at an example to make this all clear.\nIn the previous example when recording ",(0,o.kt)("inlineCode",{parentName:"p"},"Swap")," events on the USDC-WETH pool, the outputs we're getting are very raw.\nFor one, they're formatted according to the number of decimals of the token, which is not a great format to work with.\nLet's say we want to change that:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-hcl"},'query usdc_eth_swaps {\n  chain = "arbitrum"\n\n  contract {\n    address = "0x905dfCD5649217c42684f23958568e533C711Aa3"\n    abi = "unipair.abi.json"\n\n    event Swap {\n      outputs = ["amount1In", "amount0Out", "amount0In", "amount1Out"]\n    }\n\n    transform {\n      usdc_sold = parse_decimals(amount1In, 6)\n      eth_sold = parse_decimals(amount0In, 18)\n\n      usdc_bought = parse_decimals(amount1Out, 6)\n      eth_bought = parse_decimals(amount0Out, 18)\n\n      buy = amount0Out != 0\n    }\n  }\n\n  ...\n}\n')),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"apollo")," DSL provides some functions to work with, and in this case we can use ",(0,o.kt)("inlineCode",{parentName:"p"},"parse_decimals")," to do an initial clean up\nof the data. We save the results in some easy-to-remember variables that we can use later. The number ",(0,o.kt)("inlineCode",{parentName:"p"},"1")," in the outputs\nis always USDC, which has 6 decimals. Anything with the number ",(0,o.kt)("inlineCode",{parentName:"p"},"0")," is WETH, with 18 decimals."),(0,o.kt)("p",null,"We can also define a ",(0,o.kt)("inlineCode",{parentName:"p"},"buy")," boolean, which will keep track of wether the swap bought or sold WETH."),(0,o.kt)("h3",{id:"filter"},"Filter"),(0,o.kt)("p",null,"Before proceeding to our final block, we can filter out for results we're not interested in. We do this in the ",(0,o.kt)("inlineCode",{parentName:"p"},"filter"),"\nlist. Let's say we're only looking for ETH buys, and don't want to save the sells:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-hcl"},'query usdc_eth_swaps {\n  chain = "arbitrum"\n\n  contract {\n    address = "0x905dfCD5649217c42684f23958568e533C711Aa3"\n    abi = "unipair.abi.json"\n\n    event Swap {\n      outputs = ["amount1In", "amount0Out", "amount0In", "amount1Out"]\n    }\n\n    transform {\n      usdc_sold = parse_decimals(amount1In, 6)\n      eth_sold = parse_decimals(amount0In, 18)\n\n      usdc_bought = parse_decimals(amount1Out, 6)\n      eth_bought = parse_decimals(amount0Out, 18)\n    }\n  }\n\n  filter = [\n    eth_bought != 0\n  ]\n\n  save {\n    timestamp = timestamp\n    block = blocknumber\n    contract = contract_address\n    tx_hash = tx_hash\n\n    // Example: we want to calculate the price of the swap.\n    swap_price = usdc_sold / eth_bought\n    size_in_udsc = usdc_sold\n  }\n}\n')),(0,o.kt)("p",null,"If there's anything in the ",(0,o.kt)("inlineCode",{parentName:"p"},"filter")," list that evaluates to ",(0,o.kt)("inlineCode",{parentName:"p"},"false"),", the result will be discarded."),(0,o.kt)("h3",{id:"save"},"Save"),(0,o.kt)("p",null,"Our last block is the ",(0,o.kt)("inlineCode",{parentName:"p"},"save")," block. This block is at the ",(0,o.kt)("strong",{parentName:"p"},"query")," level, and it defines the final output format of our data.\nEverything that passes our ",(0,o.kt)("inlineCode",{parentName:"p"},"filter")," is available for use, including any transformed variables."),(0,o.kt)("p",null,"We'll continue to build on the previous example (but without any filters):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-hcl"},'// Note the variables!\nvariables = {\n  b = upper("eth_buy")\n  s = upper("eth_sell")\n}\n\nquery usdc_eth_swaps {\n  chain = "arbitrum"\n\n  contract {\n    address = "0x905dfCD5649217c42684f23958568e533C711Aa3"\n    abi = "unipair.abi.json"\n\n    event Swap {\n      outputs = ["amount1In", "amount0Out", "amount0In", "amount1Out"]\n    }\n\n    transform {\n      usdc_sold = parse_decimals(amount1In, 6)\n      eth_sold = parse_decimals(amount0In, 18)\n\n      usdc_bought = parse_decimals(amount1Out, 6)\n      eth_bought = parse_decimals(amount0Out, 18)\n\n      buy = amount0Out != 0\n    }\n  }\n\n  save {\n    timestamp = timestamp\n    block = blocknumber\n    contract = contract_address\n    tx_hash = tx_hash\n\n    // Example: we want to calculate the price of the swap.\n    // We have to make sure we don\'t divide by 0, so we use the ternary operator.\n    swap_price = eth_bought != 0 ? (usdc_sold / eth_bought) : (usdc_bought / eth_sold)\n    direction = buy ? b : s\n    size_in_udsc = eth_bought != 0 ? usdc_sold : usdc_bought\n  }\n}\n')),(0,o.kt)("p",null,"If we choose CSV as the output option, this would produce something like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csv",metastring:'title="usdc_eth_swaps.csv"',title:'"usdc_eth_swaps.csv"'},"size_in_udsc,timestamp,block,contract,tx_hash,swap_price,direction\n70.471237,1653105492,12604569,0x905dfCD5649217c42684f23958568e533C711Aa3,0x92da0717731b067a28663c3053998af4ca9d39164ea96024054688d5febbdfb5,1954.052675,ETH_SELL\n7831.683925,1653100138,12600500,0x905dfCD5649217c42684f23958568e533C711Aa3,0xec90864ecd0d6e8eb40bf059fd3c5d44e268871f6632fee6024a70409d24821e,1957.920981,ETH_BUY\n1508.127957,1653101447,12601445,0x905dfCD5649217c42684f23958568e533C711Aa3,0x7958274b6d9ce536f7c40f0be8441c3327c8aea788aa6a7a7c615fadd4daa567,1958.898423,ETH_BUY\n590.085622,1653101587,12601551,0x905dfCD5649217c42684f23958568e533C711Aa3,0xdf5fc5a39bc93a1cbe5480533a70fdb9da44d970c5acb17ec1bad12f01ff02a0,1959.289088,ETH_BUY\n8,1653100643,12600951,0x905dfCD5649217c42684f23958568e533C711Aa3,0x8f8de8c985a3e1118ec4abfcb3a07935a0d43d921e4d6eee35b3275200099840,1958.978772,ETH_BUY\n")),(0,o.kt)("p",null,"An important thing to note: the ",(0,o.kt)("inlineCode",{parentName:"p"},"save")," block has access to some additional context variables, and the ones we use\nhere are ",(0,o.kt)("inlineCode",{parentName:"p"},"timestamp"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"blocknumber"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"contract_address"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"tx_hash"),". See\n",(0,o.kt)("a",{parentName:"p",href:"/schema/context-variables-functions"},"Context variables and functions")," for more information."),(0,o.kt)("p",null,"In this example we also make use of the ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator"},"ternary operator")," to make sure we don't divide by 0, and to determine if the swap bought or sold WETH."),(0,o.kt)("p",null,"You've made it! If you're curious about some more use cases, check out our ",(0,o.kt)("a",{parentName:"p",href:"/schema/schema-examples"},"examples"),"."))}m.isMDXComponent=!0}}]);